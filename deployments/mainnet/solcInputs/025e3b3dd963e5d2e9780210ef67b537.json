{
  "language": "Solidity",
  "sources": {
    "contracts/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IBentoBoxMinimal.sol\";\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nabstract contract BaseStrategy is IStrategy, Ownable {\n    using SafeERC20 for IERC20;\n\n    address public immutable strategyToken;\n    address public immutable bentoBox;\n    address public immutable factory;\n    address public immutable bridgeToken;\n\n    bool public exited; /// @dev After bentobox 'exits' the strategy harvest, skim and withdraw functions can no loner be called\n    uint256 public maxBentoBoxBalance; /// @dev Slippage protection when calling harvest\n    mapping(address => bool) public strategyExecutors; /// @dev EOAs that can execute safeHarvest\n\n    bytes32 internal immutable pairCodeHash;\n\n    event LogConvert(address indexed server, address indexed token0, address indexed token1, uint256 amount0, uint256 amount1);\n    event LogSetStrategyExecutor(address indexed executor, bool allowed);\n\n    /** @param _strategyToken Address of the underlying token the strategy invests.\n        @param _bentoBox BentoBox address.\n        @param _factory SushiSwap factory.\n        @param _bridgeToken An intermedieary token for swapping any rewards into the underlying token.\n        @param _strategyExecutor an EOA that will execute the safeHarvest function.\n        @param _pairCodeHash This hash is used to calculate the address of a uniswap-like pool\n                                by providing only the addresses of the two ERC20 tokens.\n        @dev factory and bridgeToken can be address(0) if we don't expect rewards we would need to swap\n    */\n    constructor(\n        address _strategyToken,\n        address _bentoBox,\n        address _factory,\n        address _bridgeToken,\n        address _strategyExecutor,\n        bytes32 _pairCodeHash\n    ) {\n        strategyToken = _strategyToken;\n        bentoBox = _bentoBox;\n        factory = _factory;\n        bridgeToken = _bridgeToken;\n        pairCodeHash = _pairCodeHash;\n\n        if (_strategyExecutor != address(0)) {\n            strategyExecutors[_strategyExecutor] = true;\n            emit LogSetStrategyExecutor(_strategyExecutor, true);\n        }\n    }\n\n    //** Strategy implementation: override the following functions: */\n\n    /// @notice Invests the underlying asset.\n    /// @param amount The amount of tokens to invest.\n    /// @dev Assume the contract's balance is greater than the amount\n    function _skim(uint256 amount) internal virtual;\n\n    /// @notice Harvest any profits made and transfer them to address(this) or report a loss\n    /// @param balance The amount of tokens that have been invested.\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n    /// @dev amountAdded can be left at 0 when reporting profits (gas savings).\n    /// amountAdded should not reflect any rewards or tokens the strategy received.\n    /// Calcualte the amount added based on what the current deposit is worth.\n    /// (The Base Strategy harvest function accounts for rewards).\n    function _harvest(uint256 balance) internal virtual returns (int256 amountAdded);\n\n    /// @dev Withdraw the requested amount of the underlying tokens to address(this).\n    /// @param amount The requested amount we want to withdraw.\n    function _withdraw(uint256 amount) internal virtual;\n\n    /// @notice Withdraw the maximum available amount of the invested assets to address(this).\n    /// @dev This shouldn't revert (use try catch).\n    function _exit() internal virtual;\n\n    /// @notice Claim any rewards reward tokens and optionally sell them for the underlying token.\n    /// @dev Doesn't need to be implemented if we don't expect any rewards.\n    function _harvestRewards() internal virtual {}\n\n    //** End strategy implementation */\n\n    modifier isActive() {\n        require(!exited, \"BentoBox Strategy: exited\");\n        _;\n    }\n\n    modifier onlyBentoBox() {\n        require(msg.sender == bentoBox, \"BentoBox Strategy: only BentoBox\");\n        _;\n    }\n\n    modifier onlyExecutor() {\n        require(strategyExecutors[msg.sender], \"BentoBox Strategy: only Executors\");\n        _;\n    }\n\n    function setStrategyExecutor(address executor, bool value) external onlyOwner {\n        strategyExecutors[executor] = value;\n        emit LogSetStrategyExecutor(executor, value);\n    }\n\n    /// @inheritdoc IStrategy\n    function skim(uint256 amount) external override {\n        _skim(amount);\n    }\n\n    /// @notice Harvest profits while preventing a sandwich attack exploit.\n    /// @param maxBalance The maximum balance of the underlying token that is allowed to be in BentoBox.\n    /// @param rebalance Whether BentoBox should rebalance the strategy assets to acheive it's target allocation.\n    /// @param maxChangeAmount When rebalancing - the maximum amount that will be deposited to or withdrawn from a strategy to BentoBox.\n    /// @param harvestRewards If we want to claim any accrued reward tokens\n    /// @dev maxBalance can be set to 0 to keep the previous value.\n    /// @dev maxChangeAmount can be set to 0 to allow for full rebalancing.\n    function safeHarvest(\n        uint256 maxBalance,\n        bool rebalance,\n        uint256 maxChangeAmount,\n        bool harvestRewards\n    ) external onlyExecutor {\n        if (harvestRewards) {\n            _harvestRewards();\n        }\n\n        if (maxBalance > 0) {\n            maxBentoBoxBalance = maxBalance;\n        }\n\n        IBentoBoxMinimal(bentoBox).harvest(strategyToken, rebalance, maxChangeAmount);\n    }\n\n    /** @inheritdoc IStrategy\n    @dev Only BentoBox can call harvest on this strategy.\n    @dev Ensures that (1) the caller was this contract (called through the safeHarvest function)\n        and (2) that we are not being frontrun by a large BentoBox deposit when harvesting profits. */\n    function harvest(uint256 balance, address sender) external override isActive onlyBentoBox returns (int256) {\n        /** @dev Don't revert if conditions aren't met in order to allow\n            BentoBox to continiue execution as it might need to do a rebalance. */\n\n        if (sender == address(this) && IBentoBoxMinimal(bentoBox).totals(strategyToken).elastic <= maxBentoBoxBalance && balance > 0) {\n            int256 amount = _harvest(balance);\n\n            /** @dev Since harvesting of rewards is accounted for seperately we might also have\n            some underlying tokens in the contract that the _harvest call doesn't report. \n            E.g. reward tokens that have been sold into the underlying tokens which are now sitting in the contract.\n            Meaning the amount returned by the internal _harvest function isn't necessary the final profit/loss amount */\n\n            uint256 contractBalance = IERC20(strategyToken).balanceOf(address(this));\n\n            if (amount >= 0) {\n                // _harvest reported a profit\n\n                if (contractBalance > 0) {\n                    IERC20(strategyToken).safeTransfer(bentoBox, contractBalance);\n                }\n\n                return int256(contractBalance);\n            } else if (contractBalance > 0) {\n                // _harvest reported a loss but we have some tokens sitting in the contract\n\n                int256 diff = amount + int256(contractBalance);\n\n                if (diff > 0) {\n                    // we still made some profit\n\n                    /// @dev send the profit to BentoBox and reinvest the rest\n                    IERC20(strategyToken).safeTransfer(bentoBox, uint256(diff));\n                    _skim(uint256(-amount));\n                } else {\n                    // we made a loss but we have some tokens we can reinvest\n\n                    _skim(contractBalance);\n                }\n\n                return diff;\n            } else {\n                // we made a loss\n\n                return amount;\n            }\n        }\n\n        return int256(0);\n    }\n\n    /// @inheritdoc IStrategy\n    function withdraw(uint256 amount) external override isActive onlyBentoBox returns (uint256 actualAmount) {\n        _withdraw(amount);\n        /// @dev Make sure we send and report the exact same amount of tokens by using balanceOf.\n        actualAmount = IERC20(strategyToken).balanceOf(address(this));\n        IERC20(strategyToken).safeTransfer(bentoBox, actualAmount);\n    }\n\n    /// @inheritdoc IStrategy\n    /// @dev do not use isActive modifier here; allow bentobox to call strategy.exit() multiple times\n    function exit(uint256 balance) external override onlyBentoBox returns (int256 amountAdded) {\n        _exit();\n        /// @dev Check balance of token on the contract.\n        uint256 actualBalance = IERC20(strategyToken).balanceOf(address(this));\n        /// @dev Calculate tokens added (or lost).\n        amountAdded = int256(actualBalance) - int256(balance);\n        /// @dev Transfer all tokens to bentoBox.\n        IERC20(strategyToken).safeTransfer(bentoBox, actualBalance);\n        /// @dev Flag as exited, allowing the owner to manually deal with any amounts available later.\n        exited = true;\n    }\n\n    /** @dev After exited, the owner can perform ANY call. This is to rescue any funds that didn't\n        get released during exit or got earned afterwards due to vesting or airdrops, etc. */\n    function afterExit(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) public onlyOwner returns (bool success) {\n        require(exited, \"BentoBox Strategy: not exited\");\n        (success, ) = to.call{value: value}(data);\n    }\n\n    /// @notice Swap some tokens in the contract for the underlying and deposits them to address(this)\n    function swapExactTokensForUnderlying(uint256 amountOutMin, address inputToken) public onlyExecutor returns (uint256 amountOut) {\n        require(factory != address(0), \"BentoBox Strategy: cannot swap\");\n        require(inputToken != strategyToken, \"BentoBox Strategy: invalid swap\");\n\n        ///@dev Construct a path array consisting of the input (reward token),\n        /// underlying token and a potential bridge token\n        bool useBridge = bridgeToken != address(0);\n\n        address[] memory path = new address[](useBridge ? 3 : 2);\n\n        path[0] = inputToken;\n\n        if (useBridge) {\n            path[1] = bridgeToken;\n        }\n\n        path[path.length - 1] = strategyToken;\n\n        uint256 amountIn = IERC20(path[0]).balanceOf(address(this));\n\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);\n\n        amountOut = amounts[amounts.length - 1];\n\n        require(amountOut >= amountOutMin, \"BentoBox Strategy: insufficient output\");\n\n        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amounts[0]);\n\n        _swap(amounts, path, address(this));\n\n        emit LogConvert(msg.sender, inputToken, strategyToken, amountIn, amountOut);\n    }\n\n    /// @dev requires the initial amount to have already been sent to the first pair\n    function _swap(\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            address token0 = input < output ? input : output;\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2], pairCodeHash) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output, pairCodeHash)).swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\ninterface IStrategy {\n    /// @notice Send the assets to the Strategy and call skim to invest them.\n    /// @param amount The amount of tokens to invest.\n    function skim(uint256 amount) external;\n\n    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\n    /// @param balance The amount of tokens the caller thinks it has invested.\n    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n\n    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\n    /// @dev The `actualAmount` should be very close to the amount.\n    /// The difference should NOT be used to report a loss. That's what harvest is for.\n    /// @param amount The requested amount the caller wants to withdraw.\n    /// @return actualAmount The real amount that is withdrawn.\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.\n    /// @param balance The amount of tokens the caller thinks it has invested.\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\ninterface IUniswapV2Pair {\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}"
    },
    "contracts/interfaces/IBentoBoxMinimal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.7;\n\n/// @notice Minimal interface for BentoBox token vault interactions - `token` is aliased as `address` from `IERC20` for code simplicity.\ninterface IBentoBoxMinimal {\n\n    struct Rebase {\n        uint128 elastic;\n        uint128 base;\n    }\n\n    struct StrategyData {\n        uint64 strategyStartDate;\n        uint64 targetPercentage;\n        uint128 balance; // the balance of the strategy that BentoBox thinks is in there\n    }\n\n    function strategyData(address token) external view returns (StrategyData memory);\n\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token_ The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount repesented in shares.\n    function deposit(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for the BentoBox.\n    function registerProtocol() external;\n\n    function totals(address token) external view returns (Rebase memory);\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}\n"
    },
    "contracts/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"../interfaces/IUniswapV2Pair.sol\";\n\n/* \nThe following library is modified from @sushiswap/core/contracts/uniswapv2/libraries/UniswapV2Library.sol\n\nchanges: \n    - remove SafeMathUniswap library and replace all usage of it with basic operations\n    - change casting from uint to bytes20 in pair address calculation and shift by 96 bits before casting\n */\n\nlibrary UniswapV2Library {\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB,\n        bytes32 pairCodeHash\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n\n        // Since Solidity 0.8.0 explicit conversions from literals larger than type(uint160).max to address are disallowed.\n        // https://docs.soliditylang.org/en/develop/080-breaking-changes.html#new-restrictions\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            pairCodeHash // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 numerator = reserveIn * amountOut * 1000;\n        uint256 denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i], pairCodeHash);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/strategies/xJOEStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../BaseStrategy.sol\";\nimport \"../interfaces/ISushiSwap.sol\";\nimport \"../interfaces/IMasterChef.sol\";\nimport \"../libraries/Babylonian.sol\";\n\ninterface IxJOE is IERC20 {\n    function enter(uint256 _amount) external;\n    function leave(uint256 _share) external;\n} \n\ncontract XJOEStrategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n\n    event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);\n\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\n    uint256 private constant FEE = 10; // 10% fees on minted LP\n\n    ISushiSwap private immutable router;\n    IMasterChef private immutable masterchef;\n    uint256 private constant pid = 24;\n\n    IERC20 private constant JOE = IERC20(0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd);\n\n    address public feeCollector;\n\n    /** @param _strategyToken Address of the underlying LP token the strategy invests.\n        @param _bentoBox BentoBox address.\n        @param _factory SushiSwap factory.\n        @param _bridgeToken An intermediary token for swapping any rewards into it before swapping it to _inputPairToken\n        @param _strategyExecutor an EOA that will execute the safeHarvest function.\n    */\n    constructor(\n        address _strategyToken,\n        address _bentoBox,\n        address _factory,\n        address _bridgeToken,\n        address _strategyExecutor,\n        IMasterChef _masterchef,\n        ISushiSwap _router,\n        bytes32 _pairCodeHash\n    ) BaseStrategy(_strategyToken, _bentoBox, _factory, _bridgeToken, _strategyExecutor, _pairCodeHash) {\n\n        masterchef = _masterchef;\n        router = _router;\n        feeCollector = _msgSender();\n\n        IERC20(_strategyToken).safeApprove(address(_masterchef), type(uint256).max);\n        IERC20(JOE).safeApprove(address(_strategyToken), type(uint256).max);\n    }\n\n    function _skim(uint256 amount) internal override {\n        masterchef.deposit(pid, amount);\n    }\n\n    function _harvest(uint256) internal override returns (int256) {\n        masterchef.withdraw(pid, 0);\n\n        IxJOE(strategyToken).enter(JOE.balanceOf(address(this)));\n\n        uint256 total = IERC20(strategyToken).balanceOf(address(this));\n        uint256 feeAmount = (total * FEE) / 100;\n\n        IERC20(strategyToken).safeTransfer(feeCollector, feeAmount);\n\n        return int256(0);\n    }\n\n    function _withdraw(uint256 amount) internal override {\n        masterchef.withdraw(pid, amount);\n    }\n\n    function _exit() internal override {\n        masterchef.emergencyWithdraw(pid);\n    }\n\n    function setFeeCollector(address _feeCollector) external onlyOwner {\n        feeCollector = _feeCollector;\n    }\n}\n"
    },
    "contracts/interfaces/ISushiSwap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\n/// @notice Interface for SushiSwap.\ninterface ISushiSwap {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function token0() external pure returns (address);\n    function token1() external pure returns (address);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    \n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    )\n        external\n        returns (\n            uint amountA,\n            uint amountB\n        );\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}"
    },
    "contracts/interfaces/IMasterChef.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.7;\n\ninterface IMasterChef {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function userInfo(uint256 _pid, address user) external view returns (uint256 amount, uint256 rewardDebt);\n    function emergencyWithdraw(uint256 _pid) external;\n}\n\ninterface ICakeChef is IMasterChef {\n    function enterStaking(uint256 _amount) external;\n    function leaveStaking(uint256 _amount) external;\n}"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\n/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).\nlibrary Babylonian {\n    // computes square roots using the babylonian method\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}"
    },
    "contracts/strategies/LPStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../BaseStrategy.sol\";\nimport \"../interfaces/ISushiSwap.sol\";\nimport \"../interfaces/IMasterChef.sol\";\nimport \"../libraries/Babylonian.sol\";\n\ncontract LPStrategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n\n    event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);\n    uint256 private constant FEE = 10; // 10% fees on minted LP\n\n    ISushiSwap private immutable router;\n    IMasterChef private immutable masterchef;\n    uint256 private immutable pid;\n\n    address private immutable rewardToken;\n    address private immutable pairInputToken;\n    bool private immutable usePairToken0;\n\n    address public feeCollector;\n\n    /** @param _strategyToken Address of the underlying LP token the strategy invests.\n        @param _bentoBox BentoBox address.\n        @param _factory SushiSwap factory.\n        @param _bridgeToken An intermediary token for swapping any rewards into it before swapping it to _inputPairToken\n        @param _strategyExecutor an EOA that will execute the safeHarvest function.\n        @param _usePairToken0 When true, the _rewardToken will be swapped to the pair's token0 for one-sided liquidity\n                                providing, otherwise, the pair's token1.\n        @param _pairCodeHash This hash is used to calculate the address of a uniswap-like pool\n                                by providing only the addresses of the two ERC20 tokens.\n    */\n    constructor(\n        address _strategyToken,\n        address _bentoBox,\n        address _factory,\n        address _bridgeToken,\n        address _strategyExecutor,\n        IMasterChef _masterchef,\n        uint256 _pid,\n        ISushiSwap _router,\n        address _rewardToken,\n        bool _usePairToken0,\n        bytes32 _pairCodeHash\n    ) BaseStrategy(_strategyToken, _bentoBox, _factory, _bridgeToken, _strategyExecutor, _pairCodeHash) {\n        masterchef = _masterchef;\n        pid = _pid;\n        router = _router;\n        rewardToken = _rewardToken;\n        feeCollector = _msgSender();\n\n        (address token0, address token1) = _getPairTokens(_strategyToken);\n        IERC20(token0).safeApprove(address(_router), type(uint256).max);\n        IERC20(token1).safeApprove(address(_router), type(uint256).max);\n        IERC20(_strategyToken).safeApprove(address(_masterchef), type(uint256).max);\n\n        usePairToken0 = _usePairToken0;\n        pairInputToken = _usePairToken0 ? token0 : token1;\n    }\n\n    function _skim(uint256 amount) internal override {\n        masterchef.deposit(pid, amount);\n    }\n\n    function _harvest(uint256) internal override returns (int256) {\n        masterchef.withdraw(pid, 0);\n        return int256(0);\n    }\n\n    function _withdraw(uint256 amount) internal override {\n        masterchef.withdraw(pid, amount);\n    }\n\n    function _exit() internal override {\n        masterchef.emergencyWithdraw(pid);\n    }\n\n    function _getPairTokens(address _pairAddress) private pure returns (address token0, address token1) {\n        ISushiSwap sushiPair = ISushiSwap(_pairAddress);\n        token0 = sushiPair.token0();\n        token1 = sushiPair.token1();\n    }\n\n    function _swapTokens(address tokenIn, address tokenOut) private returns (uint256 amountOut) {\n        bool useBridge = bridgeToken != address(0);\n        address[] memory path = new address[](useBridge ? 3 : 2);\n\n        path[0] = tokenIn;\n\n        if (useBridge) {\n            path[1] = bridgeToken;\n        }\n\n        path[path.length - 1] = tokenOut;\n\n        uint256 amountIn = IERC20(path[0]).balanceOf(address(this));\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);\n        amountOut = amounts[amounts.length - 1];\n\n        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amounts[0]);\n        _swap(amounts, path, address(this));\n    }\n\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {\n        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\n    }\n\n    /// @notice Swap some tokens in the contract for the underlying and deposits them to address(this)\n    function swapToLP(uint256 amountOutMin) public onlyExecutor returns (uint256 amountOut) {\n        uint256 tokenInAmount = _swapTokens(rewardToken, pairInputToken);\n        (uint256 reserve0, uint256 reserve1, ) = ISushiSwap(strategyToken).getReserves();\n        (address token0, address token1) = _getPairTokens(strategyToken);\n\n        // The pairInputToken amount to swap to get the equivalent pair second token amount\n        uint256 swapAmountIn = _calculateSwapInAmount(usePairToken0 ? reserve0 : reserve1, tokenInAmount);\n\n        address[] memory path = new address[](2);\n        if (usePairToken0) {\n            path[0] = token0;\n            path[1] = token1;\n        } else {\n            path[0] = token1;\n            path[1] = token0;\n        }\n\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, swapAmountIn, path, pairCodeHash);\n        IERC20(path[0]).safeTransfer(strategyToken, amounts[0]);\n        _swap(amounts, path, address(this));\n\n        uint256 amountStrategyLpBefore = IERC20(strategyToken).balanceOf(address(this));\n\n        // Minting liquidity with optimal token balances but is still leaving some\n        // dust because of rounding. The dust will be used the next time the function\n        // is called.\n        router.addLiquidity(\n            token0,\n            token1,\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            1,\n            1,\n            address(this),\n            type(uint256).max\n        );\n\n        uint256 total = IERC20(strategyToken).balanceOf(address(this)) - amountStrategyLpBefore;\n        require(total >= amountOutMin, \"INSUFFICIENT_AMOUNT_OUT\");\n\n        uint256 feeAmount = (total * FEE) / 100;\n        amountOut = total - feeAmount;\n\n        IERC20(strategyToken).safeTransfer(feeCollector, feeAmount);\n        emit LpMinted(total, amountOut, feeAmount);\n    }\n\n    function setFeeCollector(address _feeCollector) external onlyOwner {\n        feeCollector = _feeCollector;\n    }\n}\n"
    },
    "contracts/strategies/dynamic/JoeDynamicSubLPStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"../../interfaces/IMasterChef.sol\";\nimport \"./DynamicSubLPStrategy.sol\";\n\ncontract JoeDynamicSubLPStrategy is DynamicSubLPStrategy {\n    using SafeTransferLib for ERC20;\n\n    IMasterChef public immutable masterchef;\n\n    constructor(\n        address _bentoBox,\n        address _dynamicStrategy,\n        address _strategyTokenIn,\n        address _strategyTokenOut,\n        IOracle _oracle,\n        IMasterChef _masterchef,\n        address _rewardToken,\n        uint8 _pid,\n        bool _usePairToken0,\n        RouterInfo memory _strategyTokenInInfo,\n        RouterInfo memory _strategyTokenOutInfo\n    )\n        DynamicSubLPStrategy(\n            _bentoBox,\n            _dynamicStrategy,\n            _strategyTokenIn,\n            _strategyTokenOut,\n            _oracle,\n            _rewardToken,\n            _pid,\n            _usePairToken0,\n            _strategyTokenInInfo,\n            _strategyTokenOutInfo\n        )\n    {\n        masterchef = _masterchef;\n        ERC20(_strategyTokenIn).safeApprove(address(_masterchef), type(uint256).max);\n    }\n\n    function _deposit(uint256 amount) internal override {\n        masterchef.deposit(pid, amount);\n    }\n\n    function _withdraw(uint256 amount) internal override {\n        masterchef.withdraw(pid, amount);\n    }\n\n    function _claimRewards() internal override {\n        masterchef.withdraw(pid, 0);\n    }\n\n    function _userInfo() internal view virtual override returns (uint256 amount, uint256 rewardDebt) {\n        return masterchef.userInfo(pid, address(this));\n    }\n\n    function _emergencyWithdraw() internal override {\n        masterchef.emergencyWithdraw(pid);\n    }\n}\n"
    },
    "contracts/strategies/dynamic/DynamicSubLPStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../BaseStrategy.sol\";\nimport \"../../interfaces/ISushiSwap.sol\";\nimport \"../../interfaces/IDynamicSubLPStrategy.sol\";\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../libraries/Babylonian.sol\";\n\n/// @notice DynamicSubLPStrategy sub-strategy for uniswap-forks with 0.3% fees\n/// @dev For gas saving, the strategy directly transfers to bentobox instead\n/// of transfering to DynamicLPStrategy. This contract is made abstract so we can\n/// implements fork specificities.\nabstract contract DynamicSubLPStrategy is IDynamicSubLPStrategy, Ownable {\n    using SafeTransferLib for ERC20;\n\n    event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);\n\n    struct RouterInfo {\n        address factory;\n        ISushiSwap router;\n        bytes32 pairCodeHash;\n    }\n\n    address public immutable override dynamicStrategy;\n    address public immutable override strategyTokenIn;\n    address public immutable override strategyTokenOut;\n\n    IOracle public immutable oracle;\n    address public immutable bentoBox;\n    uint8 public immutable pid;\n\n    /// @notice When true, the _rewardToken will be swapped to the pair's\n    /// token0 for one-sided liquidity providing, otherwise, the pair's token1.\n    bool public usePairToken0;\n\n    /// @notice cache of the strategyTokenOut token used to first swap the token rewards to before\n    /// splitting the liquidity in half for minting strategyTokenIn\n    address public immutable pairInputToken;\n\n    /// @notice the token farmed by staking strategyTokenIn in masterchef\n    address public immutable rewardToken;\n\n    RouterInfo public strategyTokenInInfo;\n    RouterInfo public strategyTokenOutInfo;\n\n    event LogSetStrategyExecutor(address indexed executor, bool allowed);\n\n    /** \n        @param _bentoBox BentoBox address.\n        @param _dynamicStrategy The dynamic strategy this sub strategy belongs to\n        @param _strategyTokenIn Address of the LP token the strategy is farming with\n        @param _strategyTokenOut Address of the LP token the strategy is swapping the rewardTokens to\n        @param _oracle The oracle to price the strategyTokenOut. peekSpot needs to send the inverse price in USD\n        @param _rewardToken The token the staking is farming\n        @param _pid The masterchef pool id for strategyTokenIn staking\n        @param _usePairToken0 When true, the _rewardToken will be swapped to the pair's token0 for one-sided liquidity\n                                providing, otherwise, the pair's token1.\n        @param _strategyTokenInInfo The router information to wrap strategyTokenIn from token0 and token1\n        @param _strategyTokenOutInfo The router information to swap the reward tokens for more strategyTokenOut\n    */\n    constructor(\n        address _bentoBox,\n        address _dynamicStrategy,\n        address _strategyTokenIn,\n        address _strategyTokenOut,\n        IOracle _oracle,\n        address _rewardToken,\n        uint8 _pid,\n        bool _usePairToken0,\n        RouterInfo memory _strategyTokenInInfo,\n        RouterInfo memory _strategyTokenOutInfo\n    ) {\n        bentoBox = _bentoBox;\n        dynamicStrategy = _dynamicStrategy;\n        strategyTokenIn = _strategyTokenIn;\n        strategyTokenOut = _strategyTokenOut;\n        oracle = _oracle;\n        rewardToken = _rewardToken;\n        pid = _pid;\n        usePairToken0 = _usePairToken0;\n        strategyTokenInInfo = _strategyTokenInInfo;\n        strategyTokenOutInfo = _strategyTokenOutInfo;\n\n        ERC20(_strategyTokenIn).safeApprove(address(_strategyTokenInInfo.router), type(uint256).max);\n\n        // For wrapping from token0 and token1 to strategyTokenIn\n        address token0 = ISushiSwap(_strategyTokenIn).token0();\n        address token1 = ISushiSwap(_strategyTokenIn).token1();\n        ERC20(token0).safeApprove(address(_strategyTokenInInfo.router), type(uint256).max);\n        ERC20(token1).safeApprove(address(_strategyTokenInInfo.router), type(uint256).max);\n\n        // For swapping the reward tokens to strategyTokenOut\n        token0 = ISushiSwap(_strategyTokenOut).token0();\n        token1 = ISushiSwap(_strategyTokenOut).token1();\n        ERC20(token0).safeApprove(address(_strategyTokenOutInfo.router), type(uint256).max);\n        ERC20(token1).safeApprove(address(_strategyTokenOutInfo.router), type(uint256).max);\n        pairInputToken = _usePairToken0 ? token0 : token1;\n    }\n\n    modifier onlyDynamicStrategy() {\n        require(msg.sender == dynamicStrategy, \"unauthorized\");\n        _;\n    }\n\n    function skim(uint256 amount) external override onlyDynamicStrategy {\n        _deposit(amount);\n    }\n\n    /// @dev harvest the rewardToken from masterchef and send the strategyTokenOut to bentobox.\n    /// strategyTokenOut can be obtained by calling swapToLP to swap the reward token for\n    /// more strategyTokenOut. In this case, a subsequent call to harvest is necessary for the\n    /// strategyTokenOut tokens to be available for transfer.\n    function harvest() external override onlyDynamicStrategy returns (uint256 amountAdded) {\n        _claimRewards();\n\n        /// @dev transfer the strategyTokenOut to bentobox directly and\n        /// report the amount added.\n        amountAdded = ERC20(strategyTokenOut).balanceOf(address(this));\n        ERC20(strategyTokenOut).safeTransfer(bentoBox, amountAdded);\n    }\n\n    /// @dev withdraw the specified amount from masterchef.\n    /// Only to be used when the strategyTokenIn matches the dyanmic strategyToken.\n    /// (validated inside DynamicLPStrategy.withdraw)\n    function withdraw(uint256 amount) external override onlyDynamicStrategy returns (uint256 actualAmount) {\n        _withdraw(amount);\n\n        actualAmount = ERC20(strategyTokenIn).balanceOf(address(this));\n        ERC20(strategyTokenIn).safeTransfer(bentoBox, actualAmount);\n    }\n\n    /// @dev exit everything from masterchef.\n    /// Only to be used when the strategyTokenIn matches the dyanmic strategyToken.\n    /// (validated inside DynamicLPStrategy.exit)\n    function exit() external override onlyDynamicStrategy returns (uint256 actualAmount) {\n        _emergencyWithdraw();\n\n        actualAmount = ERC20(strategyTokenIn).balanceOf(address(this));\n        ERC20(strategyTokenIn).safeTransfer(bentoBox, actualAmount);\n    }\n\n    /// @notice Swap token0 and token1 in the contract for deposits them to address(this)\n    function swapToLP(\n        uint256 amountOutMin,\n        uint256 feePercent,\n        address feeTo\n    ) public override onlyDynamicStrategy returns (uint256 amountOut) {\n        RouterInfo memory _strategyTokenOutInfo = strategyTokenOutInfo;\n\n        uint256 tokenInAmount = _swapTokens(rewardToken, pairInputToken, _strategyTokenOutInfo.factory, _strategyTokenOutInfo.pairCodeHash);\n        (uint256 reserve0, uint256 reserve1, ) = ISushiSwap(strategyTokenOut).getReserves();\n        address token0 = ISushiSwap(strategyTokenOut).token0();\n        address token1 = ISushiSwap(strategyTokenOut).token1();\n\n        // The pairInputToken amount to swap to get the equivalent pair second token amount\n        uint256 swapAmountIn = _calculateSwapInAmount(usePairToken0 ? reserve0 : reserve1, tokenInAmount);\n\n        address[] memory path = new address[](2);\n        if (usePairToken0) {\n            path[0] = token0;\n            path[1] = token1;\n        } else {\n            path[0] = token1;\n            path[1] = token0;\n        }\n\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(\n            _strategyTokenOutInfo.factory,\n            swapAmountIn,\n            path,\n            _strategyTokenOutInfo.pairCodeHash\n        );\n        ERC20(path[0]).safeTransfer(strategyTokenOut, amounts[0]);\n        _swap(amounts, path, address(this), _strategyTokenOutInfo.factory, _strategyTokenOutInfo.pairCodeHash);\n\n        uint256 amountStrategyLpBefore = ERC20(strategyTokenOut).balanceOf(address(this));\n\n        // Minting liquidity with optimal token balances but is still leaving some\n        // dust because of rounding. The dust will be used the next time the function\n        // is called.\n        _strategyTokenOutInfo.router.addLiquidity(\n            token0,\n            token1,\n            ERC20(token0).balanceOf(address(this)),\n            ERC20(token1).balanceOf(address(this)),\n            1,\n            1,\n            address(this),\n            type(uint256).max\n        );\n\n        uint256 total = ERC20(strategyTokenOut).balanceOf(address(this)) - amountStrategyLpBefore;\n        require(total >= amountOutMin, \"INSUFFICIENT_AMOUNT_OUT\");\n\n        uint256 feeAmount = (total * feePercent) / 100;\n\n        if (feeAmount > 0) {\n            amountOut = total - feeAmount;\n            ERC20(strategyTokenOut).safeTransfer(feeTo, feeAmount);\n        }\n\n        emit LpMinted(total, amountOut, feeAmount);\n    }\n\n    /// @notice wrap the token0 and token1 deposited into the contract from a previous withdrawAndUnwrapTo\n    /// and wrap into a strategyTokenIn lp token.\n    /// @param minDustAmount0 the minimum token0 left after the first addLiquidity to consider\n    /// swapping into more strategyTokenIn Lps\n    /// @param minDustAmount1 same as `minDustAmount0` but for token1\n    function wrapAndDeposit(uint256 minDustAmount0, uint256 minDustAmount1)\n        external\n        override\n        onlyDynamicStrategy\n        returns (uint256 amount, uint256 priceAmount)\n    {\n        RouterInfo memory _strategyTokenInInfo = strategyTokenInInfo;\n        address token0 = ISushiSwap(strategyTokenIn).token0();\n        address token1 = ISushiSwap(strategyTokenIn).token1();\n\n        uint256 token0Balance = ERC20(token0).balanceOf(address(this));\n        uint256 token1Balance = ERC20(token1).balanceOf(address(this));\n\n        // swap ideal amount of token0 and token1. This is likely leave some\n        // token0 or token1\n        (uint256 idealAmount0, uint256 idealAmount1, uint256 lpAmount) = _strategyTokenInInfo.router.addLiquidity(\n            token0,\n            token1,\n            token0Balance,\n            token1Balance,\n            1,\n            1,\n            address(this),\n            type(uint256).max\n        );\n\n        (uint256 reserve0, uint256 reserve1, ) = ISushiSwap(strategyTokenIn).getReserves();\n\n        // take the remaining token0 or token1 left from addliquidity and one\n        // side liquidity provide with it\n        token0Balance = token0Balance - idealAmount0;\n        token1Balance = token1Balance - idealAmount1;\n\n        if (token0Balance >= minDustAmount0 && token1Balance >= minDustAmount1) {\n            // swap remaining token0 in the contract\n            if (token0Balance > 0) {\n                uint256 swapAmountIn = _calculateSwapInAmount(reserve0, token0Balance);\n\n                token0Balance -= swapAmountIn;\n                token1Balance = _getAmountOut(swapAmountIn, reserve0, reserve1);\n\n                ERC20(token0).safeTransfer(strategyTokenIn, swapAmountIn);\n                ISushiSwap(strategyTokenIn).swap(0, token1Balance, address(this), \"\");\n            }\n            // swap remaining token1 in the contract\n            else {\n                uint256 swapAmountIn = _calculateSwapInAmount(reserve1, token1Balance);\n\n                token1Balance -= swapAmountIn;\n                token0Balance = _getAmountOut(swapAmountIn, reserve1, reserve0);\n\n                ERC20(token1).safeTransfer(strategyTokenIn, swapAmountIn);\n                ISushiSwap(strategyTokenIn).swap(token0Balance, 0, address(this), \"\");\n            }\n\n            if (token0Balance > 0 && token1Balance > 0) {\n                (, , uint256 lpAmountFromRemaining) = _strategyTokenInInfo.router.addLiquidity(\n                    token0,\n                    token1,\n                    token0Balance,\n                    token1Balance,\n                    1,\n                    1,\n                    address(this),\n                    type(uint256).max\n                );\n\n                lpAmount += lpAmountFromRemaining;\n            }\n        }\n\n        amount = lpAmount;\n        _deposit(lpAmount);\n        priceAmount = (amount * 1e18) / oracle.peekSpot(\"\");\n        emit LpMinted(lpAmount, lpAmount, 0);\n    }\n\n    /// @notice withdraw from masterchef and unwrap token0 and token1 to recipient, so that\n    /// the next strategy can use the liquidity and wrap it back.\n    /// Note: this function will potentially leave out some reward tokens, so the harvest/swapToLp/harvest routine\n    /// should be run beforehand.\n    function withdrawAndUnwrapTo(IDynamicSubLPStrategy recipient)\n        external\n        override\n        onlyDynamicStrategy\n        returns (uint256 amount, uint256 priceAmount)\n    {\n        (uint256 stakedAmount, ) = _userInfo();\n        _withdraw(stakedAmount);\n\n        address token0 = ISushiSwap(strategyTokenIn).token0();\n        address token1 = ISushiSwap(strategyTokenIn).token1();\n        amount = ERC20(strategyTokenIn).balanceOf(address(this));\n\n        /// @dev calculate the price before removing the liquidity\n        priceAmount = (amount * 1e18) / oracle.peekSpot(\"\");\n        ISushiSwap(strategyTokenInInfo.router).removeLiquidity(token0, token1, amount, 0, 0, address(recipient), type(uint256).max);\n    }\n\n    /// @notice emergency function in case of fund locked.\n    function rescueTokens(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyOwner {\n        ERC20(token).safeTransfer(to, amount);\n    }\n\n    function _swap(\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to,\n        address _factory,\n        bytes32 _pairCodeHash\n    ) private {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            address token0 = input < output ? input : output;\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(_factory, output, path[i + 2], _pairCodeHash) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(_factory, input, output, _pairCodeHash)).swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function _swapTokens(\n        address tokenIn,\n        address tokenOut,\n        address _factory,\n        bytes32 _pairCodeHash\n    ) private returns (uint256 amountOut) {\n        address[] memory path = new address[](2);\n\n        path[0] = tokenIn;\n\n        path[path.length - 1] = tokenOut;\n\n        uint256 amountIn = ERC20(path[0]).balanceOf(address(this));\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(_factory, amountIn, path, _pairCodeHash);\n        amountOut = amounts[amounts.length - 1];\n\n        ERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(_factory, path[0], path[1], _pairCodeHash), amounts[0]);\n        _swap(amounts, path, address(this), _factory, _pairCodeHash);\n    }\n\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 amountIn) internal pure returns (uint256) {\n        return (Babylonian.sqrt(reserveIn * ((amountIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    /// @dev force to reimplement masterchef interface for common staking interface\n    function _deposit(uint256 amount) internal virtual;\n\n    function _claimRewards() internal virtual;\n\n    function _withdraw(uint256 amount) internal virtual;\n\n    function _userInfo() internal view virtual returns (uint256 amount, uint256 rewardDebt);\n\n    function _emergencyWithdraw() internal virtual;\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                           EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= amount;\n        }\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_PERMIT_SIGNATURE\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IDynamicSubLPStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\nimport \"./IOracle.sol\";\n\ninterface IDynamicSubLPStrategy {\n    function dynamicStrategy() external view returns (address);\n\n    function skim(uint256 amount) external;\n\n    function harvest() external returns (uint256 amountAdded);\n\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    function exit() external returns (uint256 actualAmount);\n\n    function strategyTokenIn() external view returns (address);\n\n    function strategyTokenOut() external view returns (address);\n\n    function wrapAndDeposit(uint256 minDustAmount0, uint256 minDustAmount1) external returns (uint256 amount, uint256 amountPrice);\n\n    function withdrawAndUnwrapTo(IDynamicSubLPStrategy recipient) external returns (uint256 amount, uint256 amountPrice);\n\n    function rescueTokens(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n\n    function swapToLP(\n        uint256 amountOutMin,\n        uint256 feePercent,\n        address feeTo\n    ) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ninterface IOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable name about this oracle.\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
    },
    "contracts/strategies/dynamic/PangolinDynamicSubLPStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"../../interfaces/IMiniChefV2.sol\";\nimport \"./DynamicSubLPStrategy.sol\";\n\ncontract PangolinDynamicSubLPStrategy is DynamicSubLPStrategy {\n    using SafeTransferLib for ERC20;\n\n    IMiniChefV2 public immutable minichef;\n\n    constructor(\n        address _bentoBox,\n        address _dynamicStrategy,\n        address _strategyTokenIn,\n        address _strategyTokenOut,\n        IOracle _oracle,\n        IMiniChefV2 _minichef,\n        address _rewardToken,\n        uint8 _pid,\n        bool _usePairToken0,\n        RouterInfo memory _strategyTokenInInfo,\n        RouterInfo memory _strategyTokenOutInfo\n    )\n        DynamicSubLPStrategy(\n            _bentoBox,\n            _dynamicStrategy,\n            _strategyTokenIn,\n            _strategyTokenOut,\n            _oracle,\n            _rewardToken,\n            _pid,\n            _usePairToken0,\n            _strategyTokenInInfo,\n            _strategyTokenOutInfo\n        )\n    {\n        minichef = _minichef;\n        ERC20(_strategyTokenIn).safeApprove(address(_minichef), type(uint256).max);\n    }\n\n    function _deposit(uint256 amount) internal override {\n        minichef.deposit(pid, amount, address(this));\n    }\n\n    function _withdraw(uint256 amount) internal override {\n        minichef.withdraw(pid, amount, address(this));\n\n\n    }\n\n    function _claimRewards() internal override {\n        minichef.harvest(pid, address(this));\n    }\n\n    function _userInfo() internal view virtual override returns (uint256 amount, uint256 rewardDebt) {\n        return minichef.userInfo(pid, address(this));\n    }\n\n    function _emergencyWithdraw() internal override {\n        minichef.emergencyWithdraw(pid, address(this));\n    }\n}\n"
    },
    "contracts/interfaces/IMiniChefV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.7;\n\ninterface IMiniChefV2 {\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external;\n\n    function withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external;\n\n    function userInfo(uint256 _pid, address user) external view returns (uint256 amount, uint256 rewardDebt);\n\n    function emergencyWithdraw(uint256 _pid, address _to) external;\n\n    function harvest(uint256 _pid, address _to) external;\n\n    function rewardsExpiration() external view returns (uint256);\n\n    function fundRewards(uint256 funding, uint256 duration) external;\n\n    function resetRewardsDuration(uint256 duration) external;\n}\n"
    },
    "contracts/strategies/dynamic/DynamicLPStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\nimport \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../libraries/Babylonian.sol\";\nimport \"../../interfaces/IStrategy.sol\";\nimport \"../../interfaces/ISushiSwap.sol\";\nimport \"../../interfaces/IMasterChef.sol\";\nimport \"../../interfaces/IDynamicSubLPStrategy.sol\";\nimport \"../../interfaces/IBentoBoxMinimal.sol\";\n\n/// @notice Dynamic strategy that can have different farming strategy\n/// For example, farming on Trader Joe then unwrap the jLP to\n/// mint pLP and farm on Pengolin.\ncontract DynamicLPStrategy is IStrategy, Ownable {\n    using SafeTransferLib for ERC20;\n\n    address public immutable strategyToken;\n    address public immutable token0;\n    address public immutable token1;\n\n    address public immutable bentoBox;\n\n    address public feeCollector;\n    uint8 public feePercent;\n\n    uint256 public maxBentoBoxBalance; /// @dev Slippage protection when calling harvest\n    mapping(address => bool) public strategyExecutors; /// @dev EOAs that can execute safeHarvest\n\n    IDynamicSubLPStrategy[] public subStrategies;\n    IDynamicSubLPStrategy public currentSubStrategy;\n\n    bool public exited; /// @dev After bentobox 'exits' the strategy harvest, skim and withdraw functions can no loner be called\n\n    event LogSubStrategyAdded(address indexed subStrategy);\n    event LogSubStrategyChanged(\n        address indexed fromStrategy,\n        address indexed toStrategy,\n        uint256 amountOut,\n        uint256 amountOutPrice,\n        uint256 amountIn,\n        uint256 amountInPrice\n    );\n    event LogSetStrategyExecutor(address indexed executor, bool allowed);\n\n    /** @param _strategyToken Address of the underlying LP token the strategy invests.\n        @param _bentoBox BentoBox address.\n        @param _strategyExecutor an EOA that will execute the safeHarvest function.\n    */\n    constructor(\n        address _strategyToken,\n        address _bentoBox,\n        address _strategyExecutor\n    ) {\n        strategyToken = _strategyToken;\n        token0 = ISushiSwap(_strategyToken).token0();\n        token1 = ISushiSwap(_strategyToken).token1();\n\n        bentoBox = _bentoBox;\n\n        if (_strategyExecutor != address(0)) {\n            strategyExecutors[_strategyExecutor] = true;\n            emit LogSetStrategyExecutor(_strategyExecutor, true);\n        }\n    }\n\n    modifier isActive() {\n        require(!exited, \"BentoBox Strategy: exited\");\n        _;\n    }\n\n    modifier onlyBentoBox() {\n        require(msg.sender == bentoBox, \"BentoBox Strategy: only BentoBox\");\n        _;\n    }\n\n    /// @notice Ensure the current strategy is handling _strategyToken token so that skim,\n    /// withdraw and exit can report correctly back to bentobox.\n    modifier onlyValidStrategy() {\n        require(address(currentSubStrategy) != address(0), \"zero address\");\n        require(currentSubStrategy.strategyTokenIn() == strategyToken, \"not handling strategyToken\");\n        _;\n    }\n\n    modifier onlyExecutor() {\n        require(strategyExecutors[msg.sender], \"BentoBox Strategy: only Executors\");\n        _;\n    }\n\n    function addSubStrategy(IDynamicSubLPStrategy subStrategy) public onlyOwner {\n        require(address(subStrategy) != address(0), \"zero address\");\n        require(subStrategy.dynamicStrategy() == address(this), \"dynamicStrategy mismatch\");\n\n        /// @dev make sure the strategy pair token is using the same token0 and token1\n        ISushiSwap sushiPair = ISushiSwap(subStrategy.strategyTokenIn());\n        require(sushiPair.token0() == token0 && sushiPair.token1() == token1, \"incompatible tokens\");\n\n        subStrategies.push(subStrategy);\n        emit LogSubStrategyAdded(address(subStrategy));\n\n        if (address(currentSubStrategy) == address(0)) {\n            require(subStrategy.strategyTokenIn() == strategyToken, \"not strategyTokenIn\");\n            currentSubStrategy = subStrategy;\n\n            emit LogSubStrategyChanged(address(0), address(currentSubStrategy), 0, 0, 0, 0);\n        }\n    }\n\n    /// @param index the index of the next strategy to use\n    /// @param maxSlippageBps maximum tolerated amount of basis points of the total migrated\n    ///                   5 = 0.05%\n    ///                   10_000 = 100%\n    /// @param minDustAmount0 when the new strategy needs to wrap the token0 and token1 from previousSubStrategy\n    ///                     unwrapped token0 and token1, after initial addLiquidity, what minimum remaining\n    ///                     amount left in the contract (from new pair imbalance),\n    ///                     should be considered to swap again for more liquidity. Set to 0 to ignore.\n    /// @param minDustAmount1 same as minDustAmount0 but for token1\n    function changeStrategy(\n        uint256 index,\n        uint256 maxSlippageBps,\n        uint256 minDustAmount0,\n        uint256 minDustAmount1\n    ) public onlyExecutor {\n        require(index < subStrategies.length, \"invalid index\");\n\n        IDynamicSubLPStrategy previousSubStrategy = currentSubStrategy;\n        currentSubStrategy = subStrategies[index];\n        require(previousSubStrategy != currentSubStrategy, \"already current\");\n\n        /// @dev the next sub strategy is not using the same strategy token\n        /// and requires a convertion\n        if (previousSubStrategy.strategyTokenIn() != currentSubStrategy.strategyTokenIn()) {\n            /// @dev unwrap needs send the token0 and token1 to the next strategy directly\n            (uint256 amountFrom, uint256 priceAmountFrom) = previousSubStrategy.withdrawAndUnwrapTo(currentSubStrategy);\n\n            /// @dev wrap from the tokens sent from the previous strategy\n            (uint256 amountTo, uint256 priceAmountTo) = currentSubStrategy.wrapAndDeposit(minDustAmount0, minDustAmount1);\n\n            uint256 minToteraledPrice = priceAmountFrom - ((priceAmountFrom * maxSlippageBps) / 10_000);\n\n            require(priceAmountTo >= minToteraledPrice, \"maximumBps exceeded\");\n\n            emit LogSubStrategyChanged(\n                address(previousSubStrategy),\n                address(currentSubStrategy),\n                amountFrom,\n                priceAmountFrom,\n                amountTo,\n                priceAmountTo\n            );\n        }\n    }\n\n    /// @inheritdoc IStrategy\n    function skim(uint256 amount) external override onlyValidStrategy {\n        /// @dev bentobox transfers the token in this strategy so we need to\n        /// forward them to the sub strategy so that the specific skim can work.\n        ERC20(strategyToken).transfer(address(currentSubStrategy), amount);\n        currentSubStrategy.skim(amount);\n    }\n\n    /// @inheritdoc IStrategy\n    function withdraw(uint256 amount) external override isActive onlyBentoBox onlyValidStrategy returns (uint256 actualAmount) {\n        return currentSubStrategy.withdraw(amount);\n    }\n\n    /// @notice Harvest profits while preventing a sandwich attack exploit.\n    /// @param maxBalance The maximum balance of the underlying token that is allowed to be in BentoBox.\n    /// @param rebalance Whether BentoBox should rebalance the strategy assets to acheive it's target allocation.\n    /// @param maxChangeAmount When rebalancing - the maximum amount that will be deposited to or withdrawn from a strategy to BentoBox.\n    /// @dev maxBalance can be set to 0 to keep the previous value.\n    /// @dev maxChangeAmount can be set to 0 to allow for full rebalancing.\n    function safeHarvest(\n        uint256 maxBalance,\n        bool rebalance,\n        uint256 maxChangeAmount\n    ) external onlyExecutor {\n        if (maxBalance > 0) {\n            maxBentoBoxBalance = maxBalance;\n        }\n\n        IBentoBoxMinimal(bentoBox).harvest(strategyToken, rebalance, maxChangeAmount);\n    }\n\n    /// @inheritdoc IStrategy\n    /// @dev Only BentoBox can call harvest on this strategy.\n    /// @dev Ensures that (1) the caller was this contract (called through the safeHarvest function)\n    /// and (2) that we are not being frontrun by a large BentoBox deposit when harvesting profits.\n    /// @dev Beware that calling harvest can result in a subsequent skim or withdraw call if it's rebalancing.\n    function harvest(uint256 balance, address sender) external override isActive onlyBentoBox returns (int256) {\n        require(address(currentSubStrategy) != address(0), \"zero address\");\n\n        /// @dev Don't revert if conditions aren't met in order to allow\n        /// BentoBox to continue execution as it might need to do a rebalance.\n        if (sender == address(this) && IBentoBoxMinimal(bentoBox).totals(strategyToken).elastic <= maxBentoBoxBalance && balance > 0) {\n            return int256(currentSubStrategy.harvest());\n        }\n\n        return int256(0);\n    }\n\n    /// @inheritdoc IStrategy\n    /// @dev do not use isActive modifier here; allow bentobox to call strategy.exit() multiple times\n    function exit(uint256 balance) external override onlyBentoBox onlyValidStrategy returns (int256 amountAdded) {\n        uint256 actualBalance = currentSubStrategy.exit();\n\n        /// @dev Calculate tokens added (or lost).\n        amountAdded = int256(actualBalance) - int256(balance);\n        exited = true;\n    }\n\n    function swapToLP(uint256 amountOutMin) external onlyExecutor returns (uint256) {\n        return currentSubStrategy.swapToLP(amountOutMin, feePercent, feeCollector);\n    }\n\n    function setStrategyExecutor(address executor, bool value) external onlyOwner {\n        strategyExecutors[executor] = value;\n        emit LogSetStrategyExecutor(executor, value);\n    }\n\n    function setFeeParameters(address _feeCollector, uint8 _feePercent) external onlyOwner {\n        require(feePercent <= 100, \"invalid feePercent\");\n        feeCollector = _feeCollector;\n        feePercent = _feePercent;\n    }\n}\n"
    },
    "contracts/strategies/USTStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// solhint-disable reason-string, avoid-low-level-calls, const-name-snakecase\n\npragma solidity 0.8.7;\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IUniswapV2Pair.sol\";\nimport \"../interfaces/IBentoBoxMinimal.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IAnchorRouter {\n    function depositStable(uint256 _amount) external;\n\n    function redeemStable(uint256 _amount) external;\n}\n\ninterface IExchangeRateFeeder {\n    function exchangeRateOf(address _token, bool _simulate) external view returns (uint256);\n}\n\nabstract contract BaseStrategy is IStrategy, Ownable {\n    using SafeERC20 for IERC20;\n\n    address public immutable strategyToken;\n    address public immutable bentoBox;\n    address public immutable factory;\n    address public immutable bridgeToken;\n\n    bool public exited; /// @dev After bentobox 'exits' the strategy harvest, skim and withdraw functions can no loner be called\n    uint256 public maxBentoBoxBalance; /// @dev Slippage protection when calling harvest\n    mapping(address => bool) public strategyExecutors; /// @dev EOAs that can execute safeHarvest\n\n    event LogConvert(address indexed server, address indexed token0, address indexed token1, uint256 amount0, uint256 amount1);\n    event LogSetStrategyExecutor(address indexed executor, bool allowed);\n\n    /** @param _strategyToken Address of the underlying token the strategy invests.\n        @param _bentoBox BentoBox address.\n        @param _factory SushiSwap factory.\n        @param _bridgeToken An intermedieary token for swapping any rewards into the underlying token.\n        @param _strategyExecutor an EOA that will execute the safeHarvest function.\n        @dev factory and bridgeToken can be address(0) if we don't expect rewards we would need to swap\n    */\n    constructor(\n        address _strategyToken,\n        address _bentoBox,\n        address _factory,\n        address _bridgeToken,\n        address _strategyExecutor\n    ) {\n        strategyToken = _strategyToken;\n        bentoBox = _bentoBox;\n        factory = _factory;\n        bridgeToken = _bridgeToken;\n\n        if (_strategyExecutor != address(0)) {\n            strategyExecutors[_strategyExecutor] = true;\n            emit LogSetStrategyExecutor(_strategyExecutor, true);\n        }\n    }\n\n    //** Strategy implementation: override the following functions: */\n\n    /// @notice Invests the underlying asset.\n    /// @param amount The amount of tokens to invest.\n    /// @dev Assume the contract's balance is greater than the amount\n    function _skim(uint256 amount) internal virtual;\n\n    /// @notice Harvest any profits made and transfer them to address(this) or report a loss\n    /// @param balance The amount of tokens that have been invested.\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n    /// @dev amountAdded can be left at 0 when reporting profits (gas savings).\n    /// amountAdded should not reflect any rewards or tokens the strategy received.\n    /// Calcualte the amount added based on what the current deposit is worth.\n    /// (The Base Strategy harvest function accounts for rewards).\n    function _harvest(uint256 balance) internal virtual returns (int256 amountAdded);\n\n    /// @dev Withdraw the requested amount of the underlying tokens to address(this).\n    /// @param amount The requested amount we want to withdraw.\n    function _withdraw(uint256 amount) internal virtual;\n\n    /// @notice Withdraw the maximum available amount of the invested assets to address(this).\n    /// @dev This shouldn't revert (use try catch).\n    function _exit() internal virtual;\n\n    /// @notice Claim any rewards reward tokens and optionally sell them for the underlying token.\n    /// @dev Doesn't need to be implemented if we don't expect any rewards.\n    function _harvestRewards() internal virtual {}\n\n    //** End strategy implementation */\n\n    modifier isActive() {\n        require(!exited, \"BentoBox Strategy: exited\");\n        _;\n    }\n\n    modifier onlyBentoBox() {\n        require(msg.sender == bentoBox, \"BentoBox Strategy: only BentoBox\");\n        _;\n    }\n\n    modifier onlyExecutor() {\n        require(strategyExecutors[msg.sender], \"BentoBox Strategy: only Executors\");\n        _;\n    }\n\n    function setStrategyExecutor(address executor, bool value) external onlyOwner {\n        strategyExecutors[executor] = value;\n        emit LogSetStrategyExecutor(executor, value);\n    }\n\n    /// @inheritdoc IStrategy\n    function skim(uint256 amount) external override {\n        _skim(amount);\n    }\n\n    /// @notice Harvest profits while preventing a sandwich attack exploit.\n    /// @param maxBalance The maximum balance of the underlying token that is allowed to be in BentoBox.\n    /// @param rebalance Whether BentoBox should rebalance the strategy assets to acheive it's target allocation.\n    /// @param maxChangeAmount When rebalancing - the maximum amount that will be deposited to or withdrawn from a strategy to BentoBox.\n    /// @param harvestRewards If we want to claim any accrued reward tokens\n    /// @dev maxBalance can be set to 0 to keep the previous value.\n    /// @dev maxChangeAmount can be set to 0 to allow for full rebalancing.\n    function safeHarvest(\n        uint256 maxBalance,\n        bool rebalance,\n        uint256 maxChangeAmount,\n        bool harvestRewards\n    ) external onlyExecutor {\n        if (harvestRewards) {\n            _harvestRewards();\n        }\n\n        if (maxBalance > 0) {\n            maxBentoBoxBalance = maxBalance;\n        }\n\n        IBentoBoxMinimal(bentoBox).harvest(strategyToken, rebalance, maxChangeAmount);\n    }\n\n    /// @inheritdoc IStrategy\n    function withdraw(uint256 amount) external override isActive onlyBentoBox returns (uint256 actualAmount) {\n        _withdraw(amount);\n        /// @dev Make sure we send and report the exact same amount of tokens by using balanceOf.\n        actualAmount = IERC20(strategyToken).balanceOf(address(this));\n        IERC20(strategyToken).safeTransfer(bentoBox, actualAmount);\n    }\n\n    /// @inheritdoc IStrategy\n    /// @dev do not use isActive modifier here; allow bentobox to call strategy.exit() multiple times\n    function exit(uint256 balance) external override onlyBentoBox returns (int256 amountAdded) {\n        _exit();\n        /// @dev Check balance of token on the contract.\n        uint256 actualBalance = IERC20(strategyToken).balanceOf(address(this));\n        /// @dev Calculate tokens added (or lost).\n        amountAdded = int256(actualBalance) - int256(balance);\n        /// @dev Transfer all tokens to bentoBox.\n        IERC20(strategyToken).safeTransfer(bentoBox, actualBalance);\n        /// @dev Flag as exited, allowing the owner to manually deal with any amounts available later.\n        exited = true;\n    }\n\n    /** @dev After exited, the owner can perform ANY call. This is to rescue any funds that didn't\n        get released during exit or got earned afterwards due to vesting or airdrops, etc. */\n    function afterExit(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) public onlyOwner returns (bool success) {\n        require(exited, \"BentoBox Strategy: not exited\");\n        (success, ) = to.call{value: value}(data);\n    }\n}\n\ncontract USTStrategyV2 is BaseStrategy {\n    using SafeERC20 for IERC20;\n\n    IAnchorRouter public constant router = IAnchorRouter(0xcEF9E167d3f8806771e9bac1d4a0d568c39a9388);\n    IExchangeRateFeeder public feeder = IExchangeRateFeeder(0x24a76073Ab9131b25693F3b75dD1ce996fd3116c);\n    IERC20 public constant UST = IERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);\n    IERC20 public constant aUST = IERC20(0xa8De3e3c934e2A1BB08B010104CcaBBD4D6293ab);\n    address private constant degenBox = 0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce;\n    uint256 public fee; // fees on ust\n    address public feeCollector;\n\n    constructor(address strategyExecutor, address _feeCollector) BaseStrategy(address(UST), degenBox, address(0), address(0), strategyExecutor) {\n        UST.approve(address(router), type(uint256).max);\n        aUST.approve(address(router), type(uint256).max);\n        feeCollector = _feeCollector;\n        fee = 10;\n    }\n\n    function _skim(uint256 amount) internal override {\n        router.depositStable(amount);\n    }\n\n    /** @inheritdoc IStrategy\n    @dev Only BentoBox can call harvest on this strategy.\n    @dev Ensures that (1) the caller was this contract (called through the safeHarvest function)\n        and (2) that we are not being frontrun by a large BentoBox deposit when harvesting profits. */\n    function harvest(uint256 balance, address sender) external override isActive onlyBentoBox returns (int256) {\n        /** @dev Don't revert if conditions aren't met in order to allow\n            BentoBox to continiue execution as it might need to do a rebalance. */\n\n        if (sender == address(this) && IBentoBoxMinimal(bentoBox).totals(strategyToken).elastic <= maxBentoBoxBalance && balance > 0) {\n            int256 amount = _harvest(balance);\n\n            /** @dev Since harvesting of rewards is accounted for seperately we might also have\n            some underlying tokens in the contract that the _harvest call doesn't report. \n            E.g. reward tokens that have been sold into the underlying tokens which are now sitting in the contract.\n            Meaning the amount returned by the internal _harvest function isn't necessary the final profit/loss amount */\n            uint256 contractBalance = IERC20(strategyToken).balanceOf(address(this));\n\n            if (amount >= 0) {\n                // _harvest reported a profit\n                if (contractBalance >= uint256(amount)) {\n                    uint256 feeAmount = (uint256(amount) * fee) / 100;\n                    uint256 toTransfer = uint256(amount) - feeAmount;\n                    IERC20(strategyToken).safeTransfer(bentoBox, uint256(toTransfer));\n                    IERC20(strategyToken).safeTransfer(feeCollector, feeAmount);\n                    return (amount);\n                } else {\n                    uint256 feeAmount = (uint256(contractBalance) * fee) / 100;\n                    uint256 toTransfer = uint256(contractBalance) - feeAmount;\n                    IERC20(strategyToken).safeTransfer(bentoBox, toTransfer);\n                    IERC20(strategyToken).safeTransfer(feeCollector, feeAmount);\n                    return int256(contractBalance);\n                }\n            } else {\n                // we made a loss\n                return amount;\n            }\n        }\n\n        return int256(0);\n    }\n\n    function _harvest(uint256 balance) internal view override returns (int256) {\n        uint256 exchangeRate = feeder.exchangeRateOf(address(UST), true);\n        uint256 keep = toAUST(balance, exchangeRate);\n        uint256 total = aUST.balanceOf(address(this)) + toAUST(UST.balanceOf(address(this)), exchangeRate);\n        return int256(toUST(total, exchangeRate)) - int256(toUST(keep, exchangeRate));\n    }\n\n    function _withdraw(uint256 amount) internal override {}\n\n    function redeemEarnings() external onlyExecutor {\n        uint256 balanceToKeep = IBentoBoxMinimal(bentoBox).strategyData(address(UST)).balance;\n        uint256 exchangeRate = feeder.exchangeRateOf(address(UST), true);\n        uint256 liquid = UST.balanceOf(address(this));\n        uint256 total = toUST(aUST.balanceOf(address(this)), exchangeRate) + liquid;\n\n        if (total > balanceToKeep) {\n            router.redeemStable(toAUST(total - balanceToKeep - liquid, exchangeRate));\n        }\n    }\n\n    function safeDeposit(uint256 amount) external onlyExecutor {\n        _skim(amount);\n    }\n\n    function safeWithdraw(uint256 amount) external onlyExecutor {\n        uint256 exchangeRate = feeder.exchangeRateOf(address(UST), true);\n        uint256 requested = toAUST(amount, exchangeRate);\n        router.redeemStable(requested);\n    }\n\n    function safeWithdrawFromAUST(uint256 amount) external onlyExecutor {\n        router.redeemStable(amount);\n    }\n\n    function updateExchangeRateFeeder(IExchangeRateFeeder feeder_) external onlyOwner {\n        feeder = feeder_;\n    }\n\n    function setFeeCollector(address _feeCollector, uint256 _fee) external onlyOwner {\n        require(_fee <= 100, \"max fee is 100\");\n        feeCollector = _feeCollector;\n        fee = _fee;\n    }\n\n    function _exit() internal override {\n        try router.redeemStable(aUST.balanceOf(address(this))) {} catch {}\n    }\n\n    function toUST(uint256 amount, uint256 exchangeRate) public pure returns (uint256) {\n        return (amount * exchangeRate) / 1e18;\n    }\n\n    function toAUST(uint256 amount, uint256 exchangeRate) public pure returns (uint256) {\n        return (amount * 1e18) / exchangeRate;\n    }\n}\n"
    },
    "contracts/strategies/CakeStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../BaseStrategy.sol\";\nimport \"../interfaces/ISushiSwap.sol\";\nimport \"../interfaces/IMasterChef.sol\";\nimport \"../libraries/Babylonian.sol\";\n\n\ncontract CakeStrategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n\n    event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);\n\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\n    uint256 private constant FEE = 10; // 10% fees on minted LP\n\n    ICakeChef private immutable masterchef;\n\n    address public feeCollector;\n\n    /** @param _strategyToken Address of the underlying LP token the strategy invests.\n        @param _bentoBox BentoBox address.\n        @param _factory SushiSwap factory.\n        @param _bridgeToken An intermediary token for swapping any rewards into it before swapping it to _inputPairToken\n        @param _strategyExecutor an EOA that will execute the safeHarvest function.\n    */\n    constructor(\n        address _strategyToken,\n        address _bentoBox,\n        address _factory,\n        address _bridgeToken,\n        address _strategyExecutor,\n        ICakeChef _masterchef,\n        bytes32 _pairCodeHash\n    ) BaseStrategy(_strategyToken, _bentoBox, _factory, _bridgeToken, _strategyExecutor, _pairCodeHash) {\n\n        masterchef = _masterchef;\n        feeCollector = _msgSender();\n\n        IERC20(_strategyToken).safeApprove(address(_masterchef), type(uint256).max);\n    }\n\n    function _skim(uint256 amount) internal override {\n        masterchef.enterStaking(amount);\n    }\n\n    function _harvest(uint256) internal override returns (int256) {\n        masterchef.leaveStaking(0);\n\n        uint256 total = IERC20(strategyToken).balanceOf(address(this));\n        uint256 feeAmount = (total * FEE) / 100;\n\n        IERC20(strategyToken).safeTransfer(feeCollector, feeAmount);\n\n        return int256(0);\n    }\n\n    function _withdraw(uint256 amount) internal override {\n        masterchef.leaveStaking(amount);\n    }\n\n    function _exit() internal override {\n        masterchef.emergencyWithdraw(0);\n    }\n\n    function setFeeCollector(address _feeCollector) external onlyOwner {\n        feeCollector = _feeCollector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/mocks/USTMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nabstract contract USTMock is ERC20 {\n    constructor() ERC20(\"\",\"\") {\n        _mint(msg.sender, 1e20);\n    }\n\n    function owner() virtual external view returns (address);\n    function burn(uint256 amount, bytes32 to) virtual external;\n    function mint(address account, uint256 amount) virtual external;\n}"
    },
    "contracts/helpers/Harvester.sol": {
      "content": "// SPDX-License-Identifier: GPL-v3\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IBentoBoxMinimal.sol\";\n\npragma solidity 0.8.7;\n\ninterface ISafeStrategy {\n\tfunction safeHarvest(\n\t\tuint256 maxBalance,\n\t\tbool rebalance,\n\t\tuint256 maxChangeAmount,\n\t\tbool harvestRewards\n\t) external;\n\n    function swapExactTokensForUnderlying(uint256 amountOutMin, address inputToken) external;\n    function strategyToken() external view returns(address);\n}\n\n// \ncontract CombineHarvester is Ownable {\n\n    IBentoBoxMinimal immutable public bentoBox;\n\n    constructor(address _bentoBox) {\n        bentoBox = IBentoBoxMinimal(_bentoBox);\n    }\n\n    function executeSafeHarvests(\n        ISafeStrategy[] memory strategies,\n        bool[] memory manual,\n        uint256[] memory maxBalances,\n        bool[] memory rebalances,\n        uint256[] memory maxChangeAmounts, // can be set to 0 to allow for full withdrawals / deposits\n        bool[] memory harvestRewards,\n        uint256[] memory minOutAmounts\n    ) external onlyOwner {\n        for (uint256 i = 0; i < strategies.length; i++) {\n            \n            // BentoBox frontrunning deposit protection - likely won't be needed for Polygon since we will be frequently executing.\n            uint256 maxBalance = manual[i] ? maxBalances[i] : 0;\n            \n            // If BentoBox has to rebalance strategy assets to the target percentage.\n            bool rebalance = manual[i] ? rebalances[i] : _rebalanceNecessairy(strategies[i]);\n            \n            strategies[i].safeHarvest(maxBalance, rebalance, maxChangeAmounts[i], harvestRewards[i]);\n            \n            if (minOutAmounts[i] > 0) {\n                // we only expect wmatic rewards for the current aave strategies\n                address inputToken = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;\n                strategies[i].swapExactTokensForUnderlying(minOutAmounts[i], inputToken);\n            }\n        }\n    }\n\n    // returns true if strategy balance differs more than -+3% from the strategy target balance\n    function _rebalanceNecessairy(ISafeStrategy strategy) public view returns (bool) {\n        \n        address token = strategy.strategyToken();\n        \n        IBentoBoxMinimal.StrategyData memory data = bentoBox.strategyData(token);\n        \n        uint256 targetStrategyBalance = bentoBox.totals(token).elastic * data.targetPercentage / 100; // targetPercentage  [0, 100]\n\n        if (data.balance == 0) return targetStrategyBalance != 0;\n        \n        uint256 ratio = targetStrategyBalance * 100 / data.balance;\n        \n        return ratio >= 103 || ratio <= 97;\n    }\n}"
    },
    "contracts/mocks/ERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor() ERC20(\"\",\"\") {\n        _mint(msg.sender, 1e20);\n    }\n}"
    },
    "contracts/helpers/USTMiddleLayer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// solhint-disable const-name-snakecase\n\npragma solidity 0.8.7;\n\nimport \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IBentoBoxMinimal.sol\";\n\ninterface IExchangeRateFeeder {\n    function exchangeRateOf(address _token, bool _simulate) external view returns (uint256);\n}\n\ninterface IUSTStrategy {\n    function feeder() external view returns (IExchangeRateFeeder);\n\n    function safeWithdraw(uint256 amount) external;\n\n    function safeHarvest(\n        uint256 maxBalance,\n        bool rebalance,\n        uint256 maxChangeAmount,\n        bool harvestRewards\n    ) external;\n}\n\ncontract USTMiddleLayer {\n    using SafeTransferLib for ERC20;\n\n    error YieldNotHighEnough();\n    error StrategyWouldAccountLoss();\n\n    ERC20 public constant UST = ERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);\n    ERC20 public constant aUST = ERC20(0xa8De3e3c934e2A1BB08B010104CcaBBD4D6293ab);\n    IUSTStrategy private constant strategy = IUSTStrategy(0xE6191aA754F9a881e0a73F2028eDF324242F39E2);\n    IBentoBoxMinimal private constant bentoBox = IBentoBoxMinimal(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n\n    function accountEarnings() external {\n        uint256 balanceToKeep = IBentoBoxMinimal(bentoBox).strategyData(address(UST)).balance;\n        uint256 exchangeRate = strategy.feeder().exchangeRateOf(address(UST), true);\n        uint256 liquid = UST.balanceOf(address(strategy));\n        uint256 total = toUST(aUST.balanceOf(address(strategy)), exchangeRate) + liquid;\n\n        if (total <= balanceToKeep) {\n            revert StrategyWouldAccountLoss();\n        }\n\n        if (liquid <= 100 ether) {\n            revert YieldNotHighEnough();\n        }\n\n        strategy.safeHarvest(type(uint256).max, false, type(uint256).max, false);\n    }\n\n    function redeemEarningsImproved() external {\n        uint256 balanceToKeep = IBentoBoxMinimal(bentoBox).strategyData(address(UST)).balance;\n        uint256 exchangeRate = strategy.feeder().exchangeRateOf(address(UST), true);\n        uint256 liquid = UST.balanceOf(address(strategy));\n        uint256 total = toUST(aUST.balanceOf(address(strategy)), exchangeRate) + liquid;\n\n        if (total <= balanceToKeep) {\n            revert StrategyWouldAccountLoss();\n        }\n\n        if (total - balanceToKeep <= 100 ether) {\n            revert YieldNotHighEnough();\n        }\n\n        strategy.safeWithdraw(total - balanceToKeep - liquid);\n    }\n\n    function toUST(uint256 amount, uint256 exchangeRate) public pure returns (uint256) {\n        return (amount * exchangeRate) / 1e18;\n    }\n\n    function toAUST(uint256 amount, uint256 exchangeRate) public pure returns (uint256) {\n        return (amount * 1e18) / exchangeRate;\n    }\n}\n"
    },
    "contracts/strategies/SushiStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"../BaseStrategy.sol\";\n\ninterface ISushiBar is IERC20 {\n    function enter(uint256 _amount) external;\n\n    function leave(uint256 _share) external;\n}\n\ncontract SushiStrategy is BaseStrategy {\n    ISushiBar public immutable sushiBar;\n\n    constructor(\n        address _sushiBar,\n        address strategyToken,\n        address bentoBox,\n        address strategyExecutor,\n        bytes32 pairHashCode\n    ) BaseStrategy(strategyToken, bentoBox, strategyExecutor, address(0), address(0), pairHashCode) {\n        IERC20(strategyToken).approve(_sushiBar, type(uint256).max);\n        sushiBar = ISushiBar(_sushiBar);\n    }\n\n    function _skim(uint256 amount) internal override {\n        sushiBar.enter(amount);\n    }\n\n    function _harvest(uint256 balance) internal override returns (int256) {\n        uint256 keep = toShare(balance);\n        uint256 total = sushiBar.balanceOf(address(this));\n        if (total > keep) sushiBar.leave(total - keep);\n        // xSUSHI can't report a loss so no need to check for keep < total case\n        // we can return 0 when reporting profits (BaseContract checks balanceOf)\n        return int256(0);\n    }\n\n    function _withdraw(uint256 amount) internal override {\n        uint256 requested = toShare(amount);\n        uint256 actual = sushiBar.balanceOf(address(this));\n        sushiBar.leave(requested > actual ? actual : requested);\n    }\n\n    function _exit() internal override {\n        sushiBar.leave(sushiBar.balanceOf(address(this)));\n    }\n\n    function toShare(uint256 amount) internal view returns (uint256) {\n        uint256 totalShares = sushiBar.totalSupply();\n        uint256 totalSushi = IERC20(strategyToken).balanceOf(address(sushiBar));\n        return amount * totalShares / totalSushi;\n    }\n}\n"
    },
    "contracts/strategies/AaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"../BaseStrategy.sol\";\n\nlibrary DataTypes {\n    struct ReserveData {\n        ReserveConfigurationMap configuration;\n        uint128 liquidityIndex;\n        uint128 variableBorrowIndex;\n        uint128 currentLiquidityRate;\n        uint128 currentVariableBorrowRate;\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        address interestRateStrategyAddress;\n        uint8 id;\n    }\n    struct ReserveConfigurationMap {\n        uint256 data;\n    }\n}\n\ninterface ILendingPool {\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n}\n\ninterface IAaveIncentivesController {\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n}\n\ncontract AaveStrategy is BaseStrategy {\n    ILendingPool public immutable aaveLendingPool;\n    IAaveIncentivesController public immutable incentiveController;\n    IERC20 public immutable aToken;\n\n    constructor(\n        ILendingPool _aaveLendingPool,\n        IAaveIncentivesController _incentiveController,\n        address strategyToken,\n        address bentoBox,\n        address strategyExecutor,\n        address factory,\n        address bridgeToken,\n        bytes32 pairHashCode\n    ) BaseStrategy(strategyToken, bentoBox, factory, bridgeToken, strategyExecutor, pairHashCode)  {\n        aaveLendingPool = _aaveLendingPool;\n        incentiveController = _incentiveController;\n        aToken = IERC20(_aaveLendingPool.getReserveData(strategyToken).aTokenAddress);\n        IERC20(strategyToken).approve(address(_aaveLendingPool), type(uint256).max);\n    }\n\n    function _skim(uint256 amount) internal override {\n        aaveLendingPool.deposit(address(strategyToken), amount, address(this), 0);\n    }\n\n    function _harvest(uint256 balance) internal override returns (int256 amountAdded) {\n        uint256 currentBalance = aToken.balanceOf(address(this));\n        amountAdded = int256(currentBalance) - int256(balance);\n        if (amountAdded > 0) aaveLendingPool.withdraw(address(strategyToken), uint256(amountAdded), address(this));\n    }\n\n    function _withdraw(uint256 amount) internal override {\n        aaveLendingPool.withdraw(address(strategyToken), amount, address(this));\n    }\n\n    function _exit() internal override {\n        uint256 tokenBalance = aToken.balanceOf(address(this));\n        uint256 available = IERC20(strategyToken).balanceOf(address(aToken));\n        if (tokenBalance <= available) {\n            /// @dev If there are more tokens available than our full position, take all based on aToken balance (continue if unsuccessful).\n            try aaveLendingPool.withdraw(address(strategyToken), tokenBalance, address(this)) {} catch {}\n        } else {\n            /// @dev Otherwise redeem all available and take a loss on the missing amount (continue if unsuccessful).\n            try aaveLendingPool.withdraw(address(strategyToken), available, address(this)) {} catch {}\n        }\n    }\n\n    function _harvestRewards() internal virtual override {\n        address[] memory rewardTokens = new address[](1);\n        rewardTokens[0] = address(aToken);\n        uint256 reward = incentiveController.getRewardsBalance(rewardTokens, address(this));\n        incentiveController.claimRewards(rewardTokens, reward, address(this));\n    }\n}\n"
    },
    "contracts/strategies/AaveStrategyMainnet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.7;\n\nimport \"./AaveStrategy.sol\";\n\ninterface IStkAave {\n    function stakersCooldowns(address staker) external view returns(uint256);\n    function cooldown() external;\n    function COOLDOWN_SECONDS() external returns(uint256);\n    function UNSTAKE_WINDOW() external returns(uint256);\n    function redeem(address to, uint256 amount) external;\n    function claimRewards(address to, uint256 amount) external;\n}\n\ncontract AaveStrategyMainnet is AaveStrategy {\n\n    IStkAave public immutable stkAave;\n    uint256 public immutable COOLDOWN_SECONDS; // 10 days\n    uint256 public immutable UNSTAKE_WINDOW; // 2 days\n\n    constructor(\n        IStkAave _stkAave,\n        ILendingPool aaveLendingPool,\n        IAaveIncentivesController incentiveController,\n        address strategyToken,\n        address bentoBox,\n        address strategyExecutor,\n        address factory,\n        address bridgeToken,\n        bytes32 pairHashCode\n    ) AaveStrategy(aaveLendingPool,incentiveController,strategyToken,bentoBox,strategyExecutor,factory,bridgeToken,pairHashCode) {\n        stkAave = _stkAave;\n        COOLDOWN_SECONDS = _stkAave.COOLDOWN_SECONDS();\n        UNSTAKE_WINDOW = _stkAave.UNSTAKE_WINDOW();\n    }\n\n    function _harvestRewards() internal override {\n        if (address(stkAave) == address(0)) return;\n        \n        address[] memory rewardTokens = new address[](1);\n        rewardTokens[0] = address(aToken);\n\n        // We can pass type(uint256).max to receive all of the rewards\n        // We receive stkAAVE tokens\n        incentiveController.claimRewards(rewardTokens, type(uint256).max, address(this));\n        \n        // Now we try to unstake the stkAAVE tokens\n        uint256 cooldown = stkAave.stakersCooldowns(address(this));\n\n        if (cooldown == 0) {\n            \n            // We initiate unstaking for the stkAAVE tokens\n            stkAave.cooldown();\n\n        } else if (cooldown + COOLDOWN_SECONDS < block.timestamp) {\n\n            if (block.timestamp < cooldown + COOLDOWN_SECONDS + UNSTAKE_WINDOW) {\n\n                // We claim any AAVE rewards we have from staking AAVE\n                stkAave.claimRewards(address(this), type(uint256).max);\n                // We unstake stkAAVE and receive AAVE tokens\n                stkAave.redeem(address(this), type(uint256).max);\n\n            } else {\n            \n                // We missed the unstake window - we have to reset the cooldown timestamp\n                stkAave.cooldown();\n\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}